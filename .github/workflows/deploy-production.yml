name: Deploy to Production

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'  # Also triggers on version tags like v1.2.3
  workflow_dispatch: # Allow manual triggering

env:
  AWS_REGION: sa-east-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.sa-east-1.amazonaws.com
  BACKEND_IMAGE_NAME: revendiste/backend-production
  FRONTEND_IMAGE_NAME: revendiste/frontend-production
  FRONTEND_DIR: apps/frontend
  ECS_CLUSTER: revendiste-production-cluster
  BACKEND_SERVICE: revendiste-production-backend
  FRONTEND_SERVICE: revendiste-production-frontend

jobs:
  build-backend:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract version from tag (if applicable)
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "version_major=$(echo $VERSION | cut -d. -f1)" >> $GITHUB_OUTPUT
            echo "version_minor=$(echo $VERSION | cut -d. -f2)" >> $GITHUB_OUTPUT
            echo "Deploying version: $VERSION"
          else
            echo "Deploying from branch (using latest tag)"
          fi

      - name: Extract backend metadata
        id: backend-meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=sha,prefix=main-,enable=${{ github.ref == 'refs/heads/main' }}
            type=semver,pattern={{version}},enable=${{ startsWith(github.ref, 'refs/tags/v') }}
            type=semver,pattern={{major}}.{{minor}},enable=${{ startsWith(github.ref, 'refs/tags/v') }}
            type=semver,pattern={{major}},enable=${{ startsWith(github.ref, 'refs/tags/v') }}

      - name: Build and push backend Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./deploy/backend.Dockerfile
          push: true
          tags: ${{ steps.backend-meta.outputs.tags }}
          labels: ${{ steps.backend-meta.outputs.labels }}
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.BACKEND_IMAGE_NAME }}:buildcache,mode=max

      - name: Output backend image tags
        run: |
          echo "Backend image tags:"
          echo "${{ steps.backend-meta.outputs.tags }}"

  build-frontend:
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Extract frontend metadata
        id: frontend-meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.ECR_REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=sha,prefix=main-,enable=${{ github.ref == 'refs/heads/main' }}
            type=semver,pattern={{version}},enable=${{ startsWith(github.ref, 'refs/tags/v') }}
            type=semver,pattern={{major}}.{{minor}},enable=${{ startsWith(github.ref, 'refs/tags/v') }}
            type=semver,pattern={{major}},enable=${{ startsWith(github.ref, 'refs/tags/v') }}

      - name: Build and push frontend Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./deploy/frontend.Dockerfile
          push: true
          tags: ${{ steps.frontend-meta.outputs.tags }}
          labels: ${{ steps.frontend-meta.outputs.labels }}
          build-args: |
            ENVIRONMENT=production
          cache-from: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:buildcache
          cache-to: type=registry,ref=${{ env.ECR_REGISTRY }}/${{ env.FRONTEND_IMAGE_NAME }}:buildcache,mode=max

      - name: Output frontend image tags
        run: |
          echo "Frontend image tags:"
          echo "${{ steps.frontend-meta.outputs.tags }}"

  deploy-backend:
    runs-on: ubuntu-latest
    needs: build-backend
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Verify backend image exists
        run: |
          # Verify that the latest image was pushed successfully
          echo "Verifying backend image 'latest' exists in ECR..."
          aws ecr describe-images \
            --repository-name ${{ env.BACKEND_IMAGE_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --image-ids imageTag=latest \
            --query 'imageDetails[0].imagePushedAt' \
            --output text
          
          if [ $? -ne 0 ]; then
            echo "Error: Backend image 'latest' not found in ECR"
            exit 1
          fi
          
          echo "Backend image 'latest' verified successfully"

      - name: Update ECS backend service
        run: |
          echo "Updating ECS service: ${{ env.BACKEND_SERVICE }}"
          
          # Force new deployment to pull latest image
          # ECS will automatically pull secrets from Secrets Manager (already configured in task definition)
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.BACKEND_SERVICE }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for backend deployment to stabilize
        run: |
          echo "Waiting for backend deployment to complete..."
          
          # Wait for service to reach stable state (all tasks running and healthy)
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.BACKEND_SERVICE }} \
            --region ${{ env.AWS_REGION }}
          
          echo "Backend deployment completed successfully!"

      - name: Verify backend health
        run: |
          echo "Performing health check on https://api.revendiste.com/api/health"
          
          MAX_RETRIES=10
          RETRY_COUNT=0
          HEALTH_CHECK_URL="https://api.revendiste.com/api/health"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$HEALTH_CHECK_URL" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Health check passed! HTTP $HTTP_CODE"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check returned HTTP $HTTP_CODE, retry $RETRY_COUNT/$MAX_RETRIES..."
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              sleep 10
            fi
          done
          
          echo "Warning: Health check failed after $MAX_RETRIES attempts"
          echo "Service may still be starting up. Check CloudWatch logs for details."
          exit 0  # Don't fail the deployment if health check fails

  deploy-frontend:
    runs-on: ubuntu-latest
    needs: build-frontend
    environment: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Extract version from tag (if applicable)
        id: version
        run: |
          if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
            VERSION=${GITHUB_REF#refs/tags/v}
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "Deploying version: $VERSION"
          else
            echo "Deploying from branch (using latest tag)"
          fi

      - name: Verify frontend image exists
        run: |
          # Verify that the latest image was pushed successfully
          echo "Verifying frontend image 'latest' exists in ECR..."
          aws ecr describe-images \
            --repository-name ${{ env.FRONTEND_IMAGE_NAME }} \
            --region ${{ env.AWS_REGION }} \
            --image-ids imageTag=latest \
            --query 'imageDetails[0].imagePushedAt' \
            --output text
          
          if [ $? -ne 0 ]; then
            echo "Error: Frontend image 'latest' not found in ECR"
            exit 1
          fi
          
          echo "Frontend image 'latest' verified successfully"

      - name: Update ECS frontend service
        run: |
          echo "Updating ECS service: ${{ env.FRONTEND_SERVICE }}"
          
          # Force new deployment to pull latest image
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.FRONTEND_SERVICE }} \
            --force-new-deployment \
            --region ${{ env.AWS_REGION }}

      - name: Wait for frontend deployment to stabilize
        run: |
          echo "Waiting for frontend deployment to complete..."
          
          # Wait for service to reach stable state (all tasks running and healthy)
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.FRONTEND_SERVICE }} \
            --region ${{ env.AWS_REGION }}
          
          echo "Frontend deployment completed successfully!"

      - name: Verify frontend health
        run: |
          echo "Performing health check on https://revendiste.com"
          
          MAX_RETRIES=10
          RETRY_COUNT=0
          HEALTH_CHECK_URL="https://revendiste.com"
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 10 "$HEALTH_CHECK_URL" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "Health check passed! HTTP $HTTP_CODE"
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            echo "Health check returned HTTP $HTTP_CODE, retry $RETRY_COUNT/$MAX_RETRIES..."
            
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              sleep 10
            fi
          done
          
          echo "Warning: Health check failed after $MAX_RETRIES attempts"
          echo "Service may still be starting up. Check CloudWatch logs for details."
          exit 0  # Don't fail the deployment if health check fails

      - name: Create GitHub Release (if version tag)
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: Release ${{ steps.version.outputs.version }}
          body: |
            ## Version ${{ steps.version.outputs.version }}
            
            Production deployment completed successfully.
            
            ### Images
            - Backend: `${{ env.BACKEND_IMAGE_NAME }}:${{ steps.version.outputs.version }}`
            - Frontend: `${{ env.FRONTEND_IMAGE_NAME }}:${{ steps.version.outputs.version }}`
          draft: false
          prerelease: false

